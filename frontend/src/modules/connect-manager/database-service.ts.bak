// frontend/src/modules/connect-manager/services/database.service.ts
import { Database } from 'sqlite3';
import { open } from 'sqlite';

export interface DatabaseConfig {
  filename: string;
  mode?: number;
}

export class ConnectManagerDatabase {
  private db: any;
  private config: DatabaseConfig;

  constructor(config: DatabaseConfig = { filename: './connect-manager.db' }) {
    this.config = config;
  }

  /**
   * Initialize database connection
   */
  async initialize(): Promise<void> {
    try {
      this.db = await open({
        filename: this.config.filename,
        driver: Database
      });

      // Enable foreign keys
      await this.db.run('PRAGMA foreign_keys = ON');
      
      console.log('Database connected successfully');
    } catch (error) {
      console.error('Database connection failed:', error);
      throw error;
    }
  }

  /**
   * Close database connection
   */
  async close(): Promise<void> {
    if (this.db) {
      await this.db.close();
      console.log('Database connection closed');
    }
  }

  // ============= SCENARIOS =============

  /**
   * Get all test scenarios
   */
  async getAllScenarios(includeTemplates: boolean = false): Promise<any[]> {
    const query = includeTemplates 
      ? 'SELECT * FROM scenario_overview ORDER BY updated_at DESC'
      : 'SELECT * FROM scenario_overview WHERE is_template = 0 ORDER BY updated_at DESC';
    
    return await this.db.all(query);
  }

  /**
   * Get scenario by ID with all details
   */
  async getScenarioById(id: number): Promise<any> {
    const scenario = await this.db.get(
      'SELECT * FROM test_scenarios WHERE id = ?',
      [id]
    );

    if (!scenario) {
      return null;
    }

    // Get goals
    const goals = await this.db.all(
      'SELECT * FROM scenario_goals WHERE scenario_id = ? ORDER BY order_index',
      [id]
    );

    // Get tasks for each goal
    for (const goal of goals) {
      goal.tasks = await this.db.all(`
        SELECT 
          st.*,
          sf.name as function_name,
          sf.category as function_category,
          so.name as object_name,
          so.type as object_type
        FROM scenario_tasks st
        JOIN scenario_functions sf ON st.function_id = sf.id
        JOIN scenario_objects so ON st.object_id = so.id
        WHERE st.goal_id = ?
        ORDER BY st.order_index
      `, [goal.id]);

      // Get task parameters
      for (const task of goal.tasks) {
        task.parameters = await this.db.all(`
          SELECT 
            stp.*,
            sp.name as parameter_name,
            su.symbol as unit_symbol
          FROM scenario_task_parameters stp
          JOIN scenario_parameters sp ON stp.parameter_id = sp.id
          LEFT JOIN scenario_units su ON stp.unit_id = su.id
          WHERE stp.task_id = ?
        `, [task.id]);
      }

      // Get conditions
      goal.conditions = await this.db.all(`
        SELECT * FROM scenario_conditions 
        WHERE goal_id = ? 
        ORDER BY order_index
      `, [goal.id]);

      // Get condition parameters
      for (const condition of goal.conditions) {
        condition.parameters = await this.db.all(`
          SELECT 
            scp.*,
            sp.name as parameter_name,
            su.symbol as unit_symbol
          FROM scenario_condition_parameters scp
          JOIN scenario_parameters sp ON scp.parameter_id = sp.id
          LEFT JOIN scenario_units su ON scp.unit_id = su.id
          WHERE scp.condition_id = ?
        `, [condition.id]);
      }
    }

    // Get tags
    const tags = await this.db.all(
      'SELECT tag FROM scenario_tags WHERE scenario_id = ?',
      [id]
    );
    scenario.tags = tags.map(t => t.tag);

    scenario.goals = goals;
    return scenario;
  }

  /**
   * Create new test scenario
   */
  async createScenario(data: any): Promise<number> {
    const { name, description, author, goals, tags } = data;

    // Start transaction
    await this.db.run('BEGIN TRANSACTION');

    try {
      // Insert scenario
      const result = await this.db.run(
        'INSERT INTO test_scenarios (name, description, author) VALUES (?, ?, ?)',
        [name, description, author]
      );
      
      const scenarioId = result.lastID;

      // Insert goals
      for (let i = 0; i < goals.length; i++) {
        const goal = goals[i];
        const goalResult = await this.db.run(
          'INSERT INTO scenario_goals (scenario_id, name, description, order_index) VALUES (?, ?, ?, ?)',
          [scenarioId, goal.name, goal.description, i]
        );
        
        const goalId = goalResult.lastID;

        // Insert tasks
        for (let j = 0; j < goal.tasks.length; j++) {
          const task = goal.tasks[j];
          const taskResult = await this.db.run(
            'INSERT INTO scenario_tasks (goal_id, function_id, object_id, order_index, operator) VALUES (?, ?, ?, ?, ?)',
            [goalId, task.function_id, task.object_id, j, task.operator]
          );

          const taskId = taskResult.lastID;

          // Insert task parameters
          if (task.parameters) {
            for (const param of task.parameters) {
              await this.db.run(
                'INSERT INTO scenario_task_parameters (task_id, parameter_id, value, unit_id) VALUES (?, ?, ?, ?)',
                [taskId, param.parameter_id, param.value, param.unit_id]
              );
            }
          }
        }

        // Insert conditions
        for (let k = 0; k < goal.conditions.length; k++) {
          const condition = goal.conditions[k];
          const condResult = await this.db.run(
            'INSERT INTO scenario_conditions (goal_id, condition_type, order_index, result_action, error_message) VALUES (?, ?, ?, ?, ?)',
            [goalId, condition.type, k, condition.result_action, condition.error_message]
          );

          const condId = condResult.lastID;

          // Insert condition parameters
          if (condition.parameters) {
            for (const param of condition.parameters) {
              await this.db.run(
                'INSERT INTO scenario_condition_parameters (condition_id, parameter_id, operator, value, unit_id) VALUES (?, ?, ?, ?, ?)',
                [condId, param.parameter_id, param.operator, param.value, param.unit_id]
              );
            }
          }
        }
      }

      // Insert tags
      if (tags && tags.length > 0) {
        for (const tag of tags) {
          await this.db.run(
            'INSERT INTO scenario_tags (scenario_id, tag) VALUES (?, ?)',
            [scenarioId, tag]
          );
        }
      }

      await this.db.run('COMMIT');
      return scenarioId;

    } catch (error) {
      await this.db.run('ROLLBACK');
      throw error;
    }
  }

  /**
   * Update test scenario
   */
  async updateScenario(id: number, data: any): Promise<void> {
    const { name, description } = data;

    await this.db.run(
      'UPDATE test_scenarios SET name = ?, description = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?',
      [name, description, id]
    );

    // For complex updates (goals, tasks, etc.), we would need to:
    // 1. Delete existing goals (cascade will delete tasks and conditions)
    // 2. Re-insert new structure
    // This is simplified for demonstration
  }

  /**
   * Delete test scenario
   */
  async deleteScenario(id: number): Promise<void> {
    await this.db.run('DELETE FROM test_scenarios WHERE id = ?', [id]);
  }

  /**
   * Search scenarios by name or tag
   */
  async searchScenarios(query: string): Promise<any[]> {
    return await this.db.all(`
      SELECT DISTINCT s.*
      FROM scenario_overview s
      LEFT JOIN scenario_tags t ON s.id = t.scenario_id
      WHERE s.name LIKE ? OR s.description LIKE ? OR t.tag LIKE ?
      ORDER BY s.updated_at DESC
    `, [`%${query}%`, `%${query}%`, `%${query}%`]);
  }

  // ============= LIBRARY ELEMENTS =============

  /**
   * Get all functions
   */
  async getAllFunctions(): Promise<any[]> {
    return await this.db.all('SELECT * FROM scenario_functions ORDER BY category, name');
  }

  /**
   * Get all objects
   */
  async getAllObjects(): Promise<any[]> {
    return await this.db.all('SELECT * FROM scenario_objects ORDER BY type, name');
  }

  /**
   * Get all parameters
   */
  async getAllParameters(): Promise<any[]> {
    return await this.db.all('SELECT * FROM scenario_parameters ORDER BY name');
  }

  /**
   * Get all units
   */
  async getAllUnits(): Promise<any[]> {
    return await this.db.all(`
      SELECT u.*, p.name as parameter_name
      FROM scenario_units u
      LEFT JOIN scenario_parameters p ON u.parameter_id = p.id
      ORDER BY p.name, u.name
    `);
  }

  /**
   * Add custom function
   */
  async addFunction(name: string, category: string, description?: string): Promise<number> {
    const result = await this.db.run(
      'INSERT INTO scenario_functions (name, category, description) VALUES (?, ?, ?)',
      [name, category, description]
    );
    return result.lastID;
  }

  /**
   * Add custom object
   */
  async addObject(name: string, type: string, description?: string): Promise<number> {
    const result = await this.db.run(
      'INSERT INTO scenario_objects (name, type, description) VALUES (?, ?, ?)',
      [name, type, description]
    );
    return result.lastID;
  }

  // ============= TEMPLATES =============

  /**
   * Get all templates
   */
  async getAllTemplates(): Promise<any[]> {
    return await this.db.all('SELECT * FROM scenario_templates ORDER BY usage_count DESC, name');
  }

  /**
   * Get template by ID
   */
  async getTemplateById(id: number): Promise<any> {
    return await this.db.get('SELECT * FROM scenario_templates WHERE id = ?', [id]);
  }

  /**
   * Create template from scenario
   */
  async createTemplateFromScenario(scenarioId: number, templateName: string, category: string): Promise<number> {
    const scenario = await this.getScenarioById(scenarioId);
    
    if (!scenario) {
      throw new Error('Scenario not found');
    }

    const templateData = JSON.stringify({
      goals: scenario.goals
    });

    const result = await this.db.run(
      'INSERT INTO scenario_templates (name, description, category, template_data) VALUES (?, ?, ?, ?)',
      [templateName, scenario.description, category, templateData]
    );

    return result.lastID;
  }

  /**
   * Use template (increment usage counter)
   */
  async useTemplate(id: number): Promise<any> {
    await this.db.run(
      'UPDATE scenario_templates SET usage_count = usage_count + 1 WHERE id = ?',
      [id]
    );
    
    return await this.getTemplateById(id);
  }

  // ============= ACTIVITIES =============

  /**
   * Get all activities
   */
  async getAllActivities(): Promise<any[]> {
    return await this.db.all(`
      SELECT a.*, c.name as category_name, c.color, c.icon
      FROM activities a
      LEFT JOIN activity_categories c ON a.category_id = c.id
      WHERE a.is_active = 1
      ORDER BY c.name, a.name
    `);
  }

  /**
   * Create activity
   */
  async createActivity(data: any): Promise<number> {
    const { name, description, duration_minutes, category_id } = data;
    
    const result = await this.db.run(
      'INSERT INTO activities (name, description, duration_minutes, category_id) VALUES (?, ?, ?, ?)',
      [name, description, duration_minutes, category_id]
    );
    
    return result.lastID;
  }

  // ============= TEST ASSIGNMENTS =============

  /**
   * Get test assignments for device
   */
  async getAssignmentsByDevice(deviceId: string): Promise<any[]> {
    return await this.db.all(`
      SELECT * FROM test_assignment_details
      WHERE device_id = ?
      ORDER BY next_scheduled
    `, [deviceId]);
  }

  /**
   * Create test assignment
   */
  async createAssignment(data: any): Promise<number> {
    const { device_id, scenario_id, interval_type, interval_value } = data;
    
    // Calculate next scheduled based on interval type
    let nextScheduled = new Date();
    switch (interval_type) {
      case 'daily':
        nextScheduled.setDate(nextScheduled.getDate() + (interval_value || 1));
        break;
      case 'weekly':
        nextScheduled.setDate(nextScheduled.getDate() + (interval_value || 1) * 7);
        break;
      case 'monthly':
        nextScheduled.setMonth(nextScheduled.getMonth() + (interval_value || 1));
        break;
      case 'yearly':
        nextScheduled.setFullYear(nextScheduled.getFullYear() + (interval_value || 1));
        break;
    }

    const result = await this.db.run(`
      INSERT INTO test_type_assignments 
      (device_id, scenario_id, interval_type, interval_value, next_scheduled) 
      VALUES (?, ?, ?, ?, ?)
    `, [device_id, scenario_id, interval_type, interval_value, nextScheduled.toISOString()]);
    
    return result.lastID;
  }

  /**
   * Mark test as completed
   */
  async markTestCompleted(assignmentId: number): Promise<void> {
    const assignment = await this.db.get(
      'SELECT * FROM test_type_assignments WHERE id = ?',
      [assignmentId]
    );

    if (!assignment) {
      throw new Error('Assignment not found');
    }

    // Calculate next scheduled
    const lastPerformed = new Date();
    let nextScheduled = new Date();
    
    switch (assignment.interval_type) {
      case 'daily':
        nextScheduled.setDate(nextScheduled.getDate() + (assignment.interval_value || 1));
        break;
      case 'weekly':
        nextScheduled.setDate(nextScheduled.getDate() + (assignment.interval_value || 1) * 7);
        break;
      case 'monthly':
        nextScheduled.setMonth(nextScheduled.getMonth() + (assignment.interval_value || 1));
        break;
      case 'yearly':
        nextScheduled.setFullYear(nextScheduled.getFullYear() + (assignment.interval_value || 1));
        break;
    }

    await this.db.run(`
      UPDATE test_type_assignments 
      SET last_performed = ?, next_scheduled = ?
      WHERE id = ?
    `, [lastPerformed.toISOString(), nextScheduled.toISOString(), assignmentId]);
  }

  // ============= STATISTICS =============

  /**
   * Get database statistics
   */
  async getStatistics(): Promise<any> {
    const stats: any = {};

    stats.totalScenarios = await this.db.get('SELECT COUNT(*) as count FROM test_scenarios WHERE is_template = 0');
    stats.totalTemplates = await this.db.get('SELECT COUNT(*) as count FROM scenario_templates');
    stats.totalActivities = await this.db.get('SELECT COUNT(*) as count FROM activities WHERE is_active = 1');
    stats.totalAssignments = await this.db.get('SELECT COUNT(*) as count FROM test_type_assignments WHERE is_active = 1');
    
    stats.overdueTests = await this.db.get(`
      SELECT COUNT(*) as count 
      FROM test_type_assignments 
      WHERE is_active = 1 AND next_scheduled < CURRENT_TIMESTAMP
    `);

    stats.upcomingTests = await this.db.get(`
      SELECT COUNT(*) as count 
      FROM test_type_assignments 
      WHERE is_active = 1 
        AND next_scheduled >= CURRENT_TIMESTAMP 
        AND next_scheduled < datetime('now', '+7 days')
    `);

    stats.mostUsedTemplates = await this.db.all(`
      SELECT name, usage_count 
      FROM scenario_templates 
      ORDER BY usage_count DESC 
      LIMIT 5
    `);

    stats.recentScenarios = await this.db.all(`
      SELECT name, updated_at 
      FROM test_scenarios 
      WHERE is_template = 0
      ORDER BY updated_at DESC 
      LIMIT 5
    `);

    return stats;
  }

  // ============= EXPORT/IMPORT =============

  /**
   * Export scenario to JSON
   */
  async exportScenario(id: number): Promise<string> {
    const scenario = await this.getScenarioById(id);
    
    if (!scenario) {
      throw new Error('Scenario not found');
    }

    return JSON.stringify(scenario, null, 2);
  }

  /**
   * Import scenario from JSON
   */
  async importScenario(jsonData: string, author: string = 'imported'): Promise<number> {
    const data = JSON.parse(jsonData);
    
    // Remove ID fields to create new records
    delete data.id;
    data.author = author;
    
    if (data.goals) {
      data.goals.forEach((goal: any) => {
        delete goal.id;
        delete goal.scenario_id;
        
        if (goal.tasks) {
          goal.tasks.forEach((task: any) => {
            delete task.id;
            delete task.goal_id;
          });
        }
        
        if (goal.conditions) {
          goal.conditions.forEach((condition: any) => {
            delete condition.id;
            delete condition.goal_id;
          });
        }
      });
    }
    
    return await this.createScenario(data);
  }

  /**
   * Backup entire database
   */
  async backupDatabase(filename: string): Promise<void> {
    await this.db.backup(filename);
    console.log(`Database backed up to ${filename}`);
  }
}

// Export singleton instance
export const connectDB = new ConnectManagerDatabase();
